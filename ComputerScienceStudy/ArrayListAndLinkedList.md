# ArrayList와 LinkedList

![스크린샷 2021-09-04 오후 3.12.48](ArrayListAndLinkedList.assets/스크린샷 2021-09-04 오후 3.12.48.png)

## ArrayList

* `Array`자료구조는, 논리적 저장 순서와 물리적 저장 순서가 일치한다
* 인덱스(index)로 해당 원소에 접근할 수 있다.
* 찾고자하는 원소의 인덱스 값을 알고 있으면, 해당 원소로 접근할 수 있다
* 삭제 또는 삽입 과정에서는 해당 원소에 접근하여 작업을 완료한뒤 (O(1)), 또 한 가지의 작업을 추가적으로 해줘야 하기 때문에, 시간이 더 걸린다
  * 배열의 원소 중 어느 원소를 삭제했다고 했을 때, 배열의 연속적인 특징이 깨지게 된다
  * 삭제한 원소보다 큰 인덱스를 갖는 원소들을 `shift`해줘야 하는 비용이 발생하고 이 경우의 시간 복잡도는 O(n)가 된다
* 삽입의 경우에도 새로운 원소를 추가(첫번째 자리)하고자 한다면, 모든 원소들의 인덱스를 1씩 shift해줘야 하므로 이 경우에도 O(n)의 시간을 요구하게 된다.
* ArrayList는 내부적으로 데이터를 배열에서 관리하며 데이터의 추가, 삭제를 위해 **임시 배열을 생성해 데이터를 복사 하는 방법을 사용**
  * 대량의 자료를 추가/삭제 하는 경우에는 그만큼 데이터의 복사가 많이 일어나게 되어 성능 저하를 일으킬 수 있다. 반면 **각 데이터는 인덱스를 가지고 있기 때문에 한번에 참조가 가능해 데이터의 검색에는 유리한 구현체이다.**

* 삽입과정
  1. List의 크기를 삽입될 자료만큼 늘리는 연산을 수행
  2. 삽이될 자료의 위치를 기준으로 기존의 데이터들을 뒤로 혹은 앞으로 이동하는 연산을 수행
  3. 해당 위치에 자료를 이별한 후 삽입연산을 마침.
* 삭제과정
  1. 삭제될 자료가 위치란 인덱스의 자료를 삭제
  2. 삭제한 자료의 인덱스를 기준으로 이후의 자료들을 이동하는 연산 수행

## LinkedList

* 자료의 주소 값으로 서로를 연결되어 있는 구조
* 각각의 우너소들은 자기 자신 다음에 어떤 원소인지만을 기억하고 있다
  * 이 부분만 다른 값으로 바꿔주면 삭제와 삽입을 O(1)만에 해결할 수 있다
* 원하는 위치에 삽입을 하고자 하면 원하는 위치를 Search과정에 있어서 첫번째 원소부터 다 확인해야 한다
  * ArrayList와 달리 논리적 저장 순서와 물리적 저장 순서가 일치하지 않기때문
  * 어떤 원소를 삭제 또는 추가하고자 했을 때, 그 원소를 찾기 위해서 O(n)의 시간이 추가적으로 발생
* linked list 자료구조는 search 에도 O(n)의 time complexity 를 갖고, 삽입, 삭제에 대해서도 O(n)의 time complexity 를 갖는다.

* 삽입과정
  1. 추가될 자료의 node를 생성
  2. 추가될 자료의 해당인덱스 이전의 node의 다음 node를 추가될 node로 설정
  3. 추가될 node의 다음 node를 인덱스 이전 node의 다음 node로 설정



## Reference

[https://www.holaxprogramming.com/2014/02/12/java-list-interface/](https://www.holaxprogramming.com/2014/02/12/java-list-interface/)