# 스프링 컨테이너

## 싱글톤 컨테이너

* 스프링 컨테이너는 싱글토 ㄴ패턴의 문제점을 해결하면서, 객체 인스턴스를 싱글톤으로 관리
* 스프링 컨테이너는 싱글턴 패턴을 적용하지 않아도, 객체 인스턴스를 싱글톤으로 관리
* 스프링 컨테이너는 싱글톤 컨테이너 역할을 한다. 이렇게 싱글톤 객체를 생성하고 관리하는 기능을 **싱글톤 레지스터라** 한다.
* 스프링 컨테이너는 이런 기능 덕분에 싱글턴 패텉의 모든 단점으 ㄹ해결하ㅕㄴ서 객체를 싱글톤으로 유지할 수 있다.
  * 싱글톤 패턴을 위한 지저분한 코드가 들어가지 않아도된다.
  * DIP, OCP, 테스트, private생성자로 부터 자유롭게 싱글톤을 사용 할 수 있다.

![스크린샷 2021-09-09 오후 4.10.12](스크링 컨테이너와 스프링 빈.assets/스크린샷 2021-09-09 오후 4.10.12.png)

* 스프링 컨테이너 덕분에 곡갱의 요청이 올때마다 객체를 생성하는 것이 아니라, **이미 만들어진 객체를 공유해서 효율적으로 재사용*

```java
@Test
@DisplayName("스프링 컨테이너와 싱글톤")
void springContainer(){
    AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(AppConfig.class);

    MemberService memberService1 = ac.getBean("memberService", MemberService.class);
    MemberService memberService2 = ac.getBean("memberService", MemberService.class);

    //참조값이 같은것을 확인
    System.out.println("memberService1 = " + memberService1);
    System.out.println("memberService2 = " + memberService2);

    Assertions.assertThat(memberService1).isSameAs(memberService2);
}
```

![스크린샷 2021-09-09 오후 4.12.40](스크링 컨테이너와 스프링 빈.assets/스크린샷 2021-09-09 오후 4.12.40.png) 

## 싱글톤 방식의 주의점

> 객체 인스턴스를 하나만 생성해서 공유하는 싱글톤 방식은 여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에 싱글톤 객체는 상태를 유지 하게 설계하면 안된다.

* 무상태(stateless)로 설계해야한다.
  * 틍정 클라이언트에 의존적인 필드가 있으면 안된다.
  * 틀정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다.
  * 가급적 읽기만 가능해야 한다.
  * 필드 대신에 자바에서 공유되지 않는, 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다.
* **스프링 빈의 필드에 공유 값을 설정하면 장애가 발생할 수 있다.**

```java
public class StatefulService {
    private int price; //상태를 유지하는 필드

    public void order(String name, int price){
        System.out.println("name = " + name + ", price = " + price);
        this.price = price;
    }

    public int getPrice(){
        return price;
    }
}

public class StatefulServiceTest {
    @Test
    @DisplayName("스프링 빈의 필드에 공유 값을 설정")
    void statefulServiceSingleton(){
        ApplicationContext ac = new AnnotationConfigApplicationContext(TestConfig.class);
        StatefulService statefulService1 = ac.getBean(StatefulService.class);
        StatefulService statefulService2 = ac.getBean(StatefulService.class);

        //A사용자 10000원 주문
        statefulService1.order("userA", 10000);
        //B사용자 10000원 주문
        statefulService2.order("userB", 20000);

        //A사용자 주문 금액 조회
        int price = statefulService1.getPrice();
        System.out.println("price = " + price);

        Assertions.assertThat(statefulService1.getPrice()).isEqualTo(20000);
    }

    static class TestConfig{
        @Bean
        public StatefulService statefulService(){
            return new StatefulService();
        }
    }
}
```

![스크린샷 2021-09-09 오후 4.39.44](스크링 컨테이너와 스프링 빈.assets/스크린샷 2021-09-09 오후 4.39.44.png) 





## @Configuration

* 스프링 컨테이너는 싱글톤 레지스트리다. 따라서 스프링 빈이 싱글톤이 되도록 보장해주어야 한다

```java
@Configuration
public class AppConfig {

    //생성자 주입
    @Bean
    public MemberService memberService() {
        System.out.println("Call AppConfig.memberService");
        return new MemberServiceImpl(memberRepository());
    }

    @Bean
    public MemberRepository memberRepository() {
        System.out.println("Call AppConfig.memberRepository");
        return new MemoryMemberRepository();
    }

    @Bean
    public OrderService orderService() {
        System.out.println("Call AppConfig.orderService");
        return new OrderServiceImpl(memberRepository(), discountPolicy());
    }

    @Bean
    public DiscountPolicy discountPolicy() {
//        return new FixDiscountPolicy();
        return new RateDiscountPolicy();
    }
}
```

![스크린샷 2021-09-09 오후 5.06.15](스크링 컨테이너와 스프링 빈.assets/스크린샷 2021-09-09 오후 5.06.15.png)

* `@Bean`이 붙은 메서드마다 이미 스프링 빈이 존재하면 존재하는 빈이 반환하고, 스프링 빈이 없으면 생성해서 스프링 빈으로 등록하고 반환하는 코드가 동족어로 만들어진다.
  * 싱글톤이 보장
* `AppConfig` 스프링 빈을 조회해서 클래스 정보 확인
  * 내가 만든 클래스가 아니라 스프링이 `CGLIB` 라는 바이트코드 조작 라이브러리를 사용해서 AppConfig클래스를 상속받은 임의의 다른 클래스를 만들고 그 클래스를 스프링 빈으로 등록 한것

```java
@Test
@DisplayName("configurationDeep")
void configurationDeep(){
    ApplicationContext ac = new AnnotationConfigApplicationContext(AppConfig.class);

    AppConfig bean = ac.getBean(AppConfig.class);

    System.out.println("bean = " + bean.getClass());
}
```

```
결과
bean = class hh.core.AppConfig$$EnhancerBySpringCGLIB$$2e0979f6
```

* @Bean만 사용해도 스프링 빈으로 등록되지만, **싱글톤을 보장하지 않는다.**
  * `memberRepository()` 처럼 의존관계 주입이 필요해서 메서드를 직접 호출할 때 싱글톤을 보장하지 않는다.
* 스프링 설정 정보는 항상 `@Configuration` 을 사용