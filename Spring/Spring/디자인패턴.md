# Spring에서 사용하는 디자인패턴

## 템플릿 메서드 패턴

템플릿 메서드 패턴은 이름 그대로 템플릿을 사용하는 방식이다. 템플릿은 기준이 되는 거대한 틀이며, **템플릿이라는 틀에 변하지 않는 부분을 만들어둔다.** 그리고 **일부 변하는 부분을 별도로 호출**해서 사용.

템플릿 메서드 패턴은 부모 클래스에 변하지 않는 템플릿 코드를 두고 변하는 부분은 자식 클래스에 두고 상속과 오버라이딩을 사용해서 처리

* Abstract클래스를 상속 받아 사용

```java
@Slf4j
public abstract class AbstractTemplate {

    //변하지 않는 부분
    public void execute(){
        long startTime = System.currentTimeMillis();
        //비스니스 로직 실행
        call(); //상속
        //비스지느 로직 종료
        long endTime = System.currentTimeMillis();
        long resultTime = endTime - startTime;
        log.info("resultTime={}",resultTime);
    }

    protected abstract void call(); //변하는 부분을 자식클래스로 만들어 해결
}
```

```java
@Slf4j
public class SubClassLogic1 extends AbstractTemplate{
    @Override
    protected void call() {
        log.info("비즈니스 로직1 실행");
    }
}

@Slf4j
public class SubClassLogic2 extends AbstractTemplate{
    @Override
    protected void call() {
        log.info("비즈니스 로직2 실행");
    }
}
```

```java
@Test
void templateMethodV1_apply_template_pattern(){
    SubClassLogic1 subClassLogic1 = new SubClassLogic1();
    subClassLogic1.execute();
    SubClassLogic2 subClassLogic2 = new SubClassLogic2();
    subClassLogic2.execute();
}
```

템플릿 메서드 패턴은 `SublClassLogin1`,`SublClassLogin2`처럼 클래스를 계속 만들어서 사횽해야하는 단점이 있다.(익명 내부 클래스를 사용하면 이러한 단점을 보완할 수 있다.)

* 익명 내부클래스 사용

```java
@Test
void templateMethodV2(){
    AbstractTemplate abstractTemplate = new AbstractTemplate(){
        @Override
        protected void call() {
            log.info("비즈니스 로직1 실행");
        }
    };
    abstractTemplate.execute();

    AbstractTemplate abstractTemplate2 = new AbstractTemplate(){
        @Override
        protected void call() {
            log.info("비즈니스 로직2 실행");
        }
    };
    abstractTemplate2.execute();
}
```



## 전략 패턴

알고리즘 제품군을 정의하고 각각을 캡슐화하여 상호 교환 가능하게 만든다. 전력을 사용하면 알고리즘을 사요하는 클라이언트와 독립적으로 알고리즘을 변경할 수 있다.

### 필드에 전략을 보관하는 방식

> 생성자를 통해 주입

* 선조립, 후 실행 방법에 적합하다.
* `context`를실행하는 시점에는 이미 조립이 끝났기 때문에 전략을 신경쓰지 않고 단순히 실행만 하면 된다.

```java
public interface Strategy {
    void call();
}
```

```java
/**
 * 필드에 전략을 보관하는 방식
 */
@Slf4j
public class ContextV1 {
    private Strategy strategy;

    public ContextV1(Strategy strategy) {
        this.strategy = strategy;
    }

    public void execute() {
        long startTime = System.currentTimeMillis();
        //비즈니스 로직 실행
        strategy.call();    //위임
        //비즈니스 로직 종료
        long endTime = System.currentTimeMillis();
        long resultTime = endTime - startTime;
        log.info("resultTime={}", resultTime);
    }
}
```

```java
@Slf4j
public class StrategyLogic1 implements Strategy{
    @Override
    public void call() {
        log.info("비즈니스 로직1 실행");
    }
}

@Slf4j
public class StrategyLogic2 implements Strategy{
    @Override
    public void call() {
        log.info("비즈니스 로직2 실행");
    }
}
```

```java
@Test
void strategyV1(){
    StrategyLogic1 strategyLogic1 = new StrategyLogic1();
    ContextV1 context1 = new ContextV1(strategyLogic1);
    context1.execute();

    StrategyLogic2 strategyLogic2 = new StrategyLogic2();
    ContextV1 context2 = new ContextV1(strategyLogic2);
    context2.execute();
}
```

컨텍스트(문맥)는 크게 변하지 않지만, 그 문맥 속에서 strategy 를 통해 일부 전략이 변경된다

`Context` 는 내부에 `Strategy strategy` 필드를 가지고 있으며, 생성자를 통해 Strategy 의 구현체를 주입한다.
 전략 패턴의 핵심은 Context 는 Strategy 인터페이스에만 의존한다는 점이며,  Strategy 의 구현체를 변경하거나 새로 만들어도 Context 코드에는 영향을 주지 않는다.

스프링의 의존관계 주입에서 사용하는 방식은 전략패턴이다.

### 전략을 파라미터로 전달 받는 방식

> `execute()`가 호출될 때마다 항상 파라미터로 전달 받는다.

* 실행을 할때마다 전략을 유연하게 변경할 수 있다.
* 실행할 때 마다 전략을 계속 지정해주어야한다는 단점이 있다.

```java
@Slf4j
public class ContextV2 {

    public void execute(Strategy strategy) {
        long startTime = System.currentTimeMillis();
        //비즈니스 로직 실행
        strategy.call();    //위임
        //비즈니스 로직 종료
        long endTime = System.currentTimeMillis();
        long resultTime = endTime - startTime;
        log.info("resultTime={}", resultTime);
    }
}
```

```java
@Slf4j
public class ContextV2Test {

    @Test
    void strategyV1(){
        ContextV2 contextV2 = new ContextV2();
        contextV2.execute(new StrategyLogic1());
        contextV2.execute(new StrategyLogic2());
    }

    @Test
    void strategyV2_anonymous_inner_class(){
        ContextV2 contextV2 = new ContextV2();
        contextV2.execute(new Strategy() {
            @Override
            public void call() {
                log.info("비즈니스 로직1 실행");
            }
        });
        contextV2.execute(new Strategy() {
            @Override
            public void call() {
                log.info("비즈니스 로직2 실행");
            }
        });
    }

    @Test
    void strategyV3_lambda(){
        ContextV2 contextV2 = new ContextV2();
        contextV2.execute(() ->log.info("비즈니스 로직1 실행"));
        contextV2.execute(() -> log.info("비즈니스 로직2 실행"));
    }
}
```

`Context`를실행하는 시점에 원하는 `Strategy`를전달할 수 있으며, 필드에 전략을 보관하는 방식과 비교해서 원하는 전략을 더욱 유연하게 변경할 수 있다.

## 템플릿 콜백 패턴

> 프로그래밍에서  callback 또는 call-after function은 다른 코드의 인수로서 넘겨주는 실행 가능한 코드를 말한다.
> 콜백을 넘겨받은 코드는 이 콜백을 필요에 따라 즉시 실행할 수도 있고, 나중에 실행할 수도 있다.
>
> 스프링에서는 `JdbcTemplate`, `RestTemplate`, `TransactionTemplate`, `RedisTemplate` 처럼 다양한 템플릿 콜백 패턴이 사용되며, 스프링에서 이름에 `xxxxxTemplate` 가 있으면 템플릿 콜백 패턴으로 만들어져 있다고 생각하면 된다.

* Java에서 콜백
  * 자바에서 실행 가능한 코드를 인수로 넘기려면 객체가 필요하다, 자파8부터는 람다를 사용할 수 있다.
  * 자바8 이전에는 보통 하나의 메소드를 가진 인터페이스를 구현하고, 주로 익명 내부클래스를 사용했다.
  * 최근에는 주로 lambda를 사용

