# Spring에서 사용하는 디자인패턴

## 템플릿 메서드 패턴

템플릿 메서드 패턴은 이름 그대로 템플릿을 사용하는 방식이다. 템플릿은 기준이 되는 거대한 틀이며, **템플릿이라는 틀에 변하지 않는 부분을 만들어둔다.** 그리고 **일부 변하는 부분을 별도로 호출**해서 사용.

템플릿 메서드 패턴은 부모 클래스에 변하지 않는 템플릿 코드를 두고 변하는 부분은 자식 클래스에 두고 상속과 오버라이딩을 사용해서 처리

* Abstract클래스를 상속 받아 사용

```java
@Slf4j
public abstract class AbstractTemplate {

    //변하지 않는 부분
    public void execute(){
        long startTime = System.currentTimeMillis();
        //비스니스 로직 실행
        call(); //상속
        //비스지느 로직 종료
        long endTime = System.currentTimeMillis();
        long resultTime = endTime - startTime;
        log.info("resultTime={}",resultTime);
    }

    protected abstract void call(); //변하는 부분을 자식클래스로 만들어 해결
}
```

```java
@Slf4j
public class SubClassLogic1 extends AbstractTemplate{
    @Override
    protected void call() {
        log.info("비즈니스 로직1 실행");
    }
}

@Slf4j
public class SubClassLogic2 extends AbstractTemplate{
    @Override
    protected void call() {
        log.info("비즈니스 로직2 실행");
    }
}
```

```java
@Test
void templateMethodV1_apply_template_pattern(){
    SubClassLogic1 subClassLogic1 = new SubClassLogic1();
    subClassLogic1.execute();
    SubClassLogic2 subClassLogic2 = new SubClassLogic2();
    subClassLogic2.execute();
}
```

템플릿 메서드 패턴은 `SublClassLogin1`,`SublClassLogin2`처럼 클래스를 계속 만들어서 사횽해야하는 단점이 있다.(익명 내부 클래스를 사용하면 이러한 단점을 보완할 수 있다.)

* 익명 내부클래스 사용

```java
@Test
void templateMethodV2(){
    AbstractTemplate abstractTemplate = new AbstractTemplate(){
        @Override
        protected void call() {
            log.info("비즈니스 로직1 실행");
        }
    };
    abstractTemplate.execute();

    AbstractTemplate abstractTemplate2 = new AbstractTemplate(){
        @Override
        protected void call() {
            log.info("비즈니스 로직2 실행");
        }
    };
    abstractTemplate2.execute();
}
```



## 전략 패턴

## 템플릿 메서드 패턴

